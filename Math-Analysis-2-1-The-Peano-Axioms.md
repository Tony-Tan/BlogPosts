---
title: 【陶哲轩实分析】2.1 Peano 公理
categories:
    - Mathematic
    - Analysis
keywords:
    - The Peano Axioms
toc: true
date: 2018-03-19 15:18:44
---

**Abstract:** Peano公理
**Keywords:** Peano公理，归纳法，递归定义

<!--more-->
说明：<font face="黑体" color=#6F6FFF><B>以这种字体存在的博文，来自《陶哲轩实分析》的内容完整节选，版权归原作者和出版社所有</B></font>

---------------


## Peano 公理
<font face="黑体" color=#6F6FFF><B>
我们现在用Peano公理的语言提出一个定义自然数的标准方法，Peano公理是Guiseppe Peano(1858—1932)首先提出的。这不是定义自然数的唯一方法。例如，另一个途径是用有限集的基数，比方说，可以取一个5个元素的集合并定义5是此集合的元素个数。我们将在§3.6中讨论这种方法。但是我们眼下仅用Peano公理的方式。</B></font>

---------------

公理化的自然数定义并不是最早的定义方法，关于自然数的出现，应该比定义要早很多，后面出现了各种各样的定义，我们从Peano公理出发来构建数系，进而构建数学基础体系，公理化的数学是近代数学的大进步，关于集合的方法定义自然数，后面第三章有简单介绍。

---------------

<font face="黑体" color=#6F6FFF><B>
我们怎样定义自然数是什么呢？不正式地可以说
**定义2.1.1**(不正式的）自然数是指集合 </B></font>
$$
N:=\{0,1,2,3,4,\dots\}
$$
<font face="黑体" color=#6F6FFF><B>
的元素，此集合是由从0开始无休止地往前数所得到的一切数的集。我们把 $\mathbb{N}$ 叫作自然数集.
注2.1.2:在有些教材中，自然数是从1开始而不是从0开始的，但这只是一个符号的约定而已。本书中我们把 $\{1,2,3,4,\dots\}$ 叫作正整数集，用 $\mathbb{Z}^+$ 代表而不叫自然数集。自然数有时也被叫作完整数(whole numbers)。
</B></font>

---------------
不正式的定义就是我们的感觉，有些事情处于我们的知识限制，我们没办法给出科学的严谨的定义，我们更多的是描述，比如我们使用了这么多年的自然数，我们上一篇说把我们知道的算数知识都忘掉，但是我们会数123的这个属性可以不用忘，123就是自然数，但是我们能用自己的语言定义自然数么？显然有点困难，我们只能说 $\{0,1,2,3,4,\dots\}$ 就是自然数，而且大家的描述有奇异，就是有些人认为0不是自然数，我还记得我小时后学的自然数定义：“表示物体数量的数字叫做自然数，一个物体也没有的时候用0表示，所以0也是自然数”，当然我们马上就要得到更精确的定义，但是我们必须先规定一下，0是自然数，为什么这个东西可以规定而不是靠逻辑证明？我们看下面的描述。

---------------

<font face="黑体" color=#6F6FFF><B>
这个定义在一定意义上解决了自然数是什么的问题：一个自然数乃是集合 $\mathbb{N}^+$ 的一个元素但是，这并不是完全可接受的，因为它遗留下许多没有回答的问题。例如：怎能知道我们可以无休止地数下去而不会循环回到0？你怎样实行运算，如加法、乘法或指数运算？
</B></font>

---------------

涉及到数系的建立，我们构建数系最重要的目的是使用，所以很多性质我们在构建数系之初就已经要设计好，比如这个系统有多少组成部分，如何完成操作，等。

---------------

<font face="黑体" color=#6F6FFF><B>
我们可以首先回答最后一个问题：可以通过简单的运算来定义复杂的运算。指数运算只不过是重复的乘法运算：53是3个5乘在一起；乘法只不过是加法的重复：$5\times 3$ 是3个5加在一起；（此处没谈到减法和除法，因为这两种运算不是完全适用于自然数系的运算。）而加法呢？这只不过是向前数(动词)或增长的重复运作：如果你把5加上3,你所做的只不过是让5增长3次。另一方面，增长似乎是一个基本的运算，它没法再归结为更简单的运算；的确，它是人们遇到的关于数的第一个运算，甚至在学习加法之前.
</B></font>

---------------

在设计数系内操作的时候也就是设计计算性质，自然数加法乘法我们都会做也知道其实质，但是我们假设我们不会做计算，但是设计数系之初，我们就设计了数系的一个特征：比如增长，我们再来设计数系里面的计算的性质，也就是加法是增长的重复，乘法是加法的重复，指数计算是乘法的重复，而归根到底，自然数的运算都是建立在增长的数系性质上的。

---------------

<font face="黑体" color=#6F6FFF><B>
于是，为了定义自然数，我们将使用两个基础性的概念：数零0以及增长运算。依照现代计算机语言，我们用 $n++$ 代表 $n$ 的增额(increment)或 $n$ 的后继者(successor)，于是，譬如说，$3++=4$ ，$(3++)++=5$ ,等等。这是计算机语言，例如C语言的一个稍微不同的应用，在计算机语言中，n++ 实际上重新定义n的值为n的后继者；但在数学中，我们在任何情况下都尽力避免把一个变元定义两次，因为这常引起混淆。很多命题对于变元的旧的值是真确的而现在却变成假的，反之亦然。
于是，似乎我们要说N是由0和每个可由0经增长而得者所组成：N应是由对象 $0,0++,(0++)++,((0++)++)++,\dots$ 等所组成.如果我们着手写出关于自然数这意味着什么，那么我们看到，应该有下述的涉及0和增长运算++的公理：
</B></font>

---------------

所以根据上面我们分析的，自然数计算，我们得到了一个重要结论：
1. 定义一个增加性质
2. 自然数的一个开始

这些是必须的，那么从0不断的增加就能得到很多自然数，而我们用符号0表示自然数的开始，然后通过我们定义的增加的性质来定义更多的计算。
有了这两个性质，剩下的就是发明一些符号，和一些附加规则，来规范增长（每次增长有没有不同），规范范围（比如一共有多少个自然数）


---------------

<font face="黑体" color=#6F6FFF><B>
**公理2.1**	0是一个自然数.
</B></font>

---------------

定义自然数的一个开始

---------------

<font face="黑体" color=#6F6FFF><B>
**公理2.2** 若n是自然数，则 $n++$ 也是自然数.
</B></font>

---------------

定义自增运算，也就是从0开始，后面的数和前面的数之间的关系，如果认为0是自然数的祖宗，那么怎么生出来后面的数？增长运算！

---------------

<font face="黑体" color=#6F6FFF><B>
于是，作为例子，从公理2.1和公理2.2的两次使用，我们看到 $(0++)++$ 是一个自然数.当然，这个记号开始变得不好使了，所以我们约定用更熟悉的记号来 写这些数：
定义2.1.3 定义1是数 $0++$ ，2是数 $(0++)++$ ，3是数 $((0++)++)++)$，等等。（换言之， $1:=0++,2:=1++,3:=2++$ ,等等。本书中我们用"x;=y"表示命题 $x$ 定义为等于 $y$ )
严格地说，对于这个非正式的定义还有另一个问题：我们尚不曾定义“集合”是什么，也不曾定义“集合的元素” 是什么。因此，在本章的其他部分，我们将尽可能避免提及集合及其元素，除了是在非正式的讨论中。
</B></font>

---------------

上面就是根据我们的构想，通过一个自然数的开始，和一个自然数之间的自增关系，来获得自然数，比如0的后继我们用1来定义，当然也可以用a，1的后继是2，当然也可以是a的后继是b等着一系列的方法，来定义数系中每一个自然数的表示方法，定义1，2，3只是定义了一种表达方式，并不是定义其实质，实质是若干条公理定义的，1，2，3，4等只是个符号或者名字，没有实际意义。

---------------

<font face="黑体" color=#6F6FFF><B>
**命题2.1.4**	3是自然数。
</B></font>

---------------

1. 根据公理2.1，0是自然数
2. 根据公理2.2，$0++=1$ 是自然数。
3. 再用公理2.2，$1++=2$ 是自然数。
4. 再用公理2.2，$2++=3$ 是自然数。
Q.E.D

---------------

<font face="黑体" color=#6F6FFF><B>
对于描述自然数，好像这己经足够了。但是我们还没有完全说清楚N的性状：
</B></font>

---------------

明显是不够足够的，还有很多漏洞，比如说我们一共有多少个自然数？非正式的说法，增长方式根本没说清楚，换句话说增长路径没明确！

---------------

<font face="黑体" color=#6F6FFF><B>
例2.1.5 考虑由数 $0,1,2,3$ 组成的数系，在此数系中，增长运算到3转回到0。确言之， $0++$ 等于1，$1++$ 等于2, $2++$ 等于3,但 $3++$ 等于0(而根据4的定义，它也等于4).这类事情确实发生在现实生活中。
</B></font>

---------------

上述的这种情况和前面的的定义完全不冲突，所以不冲突就是对的，但是0=4这种事确实有点不妥，但是生活中也有，比如计算机数字类型，比如c语言中int的溢出，更常见的是看看我们的时钟，12点之后又变成了1点，也就是13=1。

---------------

<font face="黑体" color=#6F6FFF><B>
为避免这类“回归事件”，我们要加上另一个公理：
**公理2.3** 0不是任何自然数的后继，即对于每个自然数n，都有 $n++\neq 0$ 。

</B></font>

---------------

这个公理确定了0是自然数的开始，也就是不存在任何一个自然数，其后继可以是0。
这就排除了上面自然数变成循环形式的可能。

---------------

<font face="黑体" color=#6F6FFF><B>

命题2.1.6	4不等于0.
别笑！根据我们定义数4的方法——它是0的增长的增长的增长的增长—— 此数与零不是同一个数，这一命题尽管是“明显的”却不必是真确的(a priodf).注意，作为例子，在例2.1.5中，4的确等于0，并且在标准的2字节计算机上，一个自然数，例如65 536等于0(用我们对65 536的定义，它等于0增长六万五千五百三十六次).
证明根据定义， $4=3++$ 。根据公理2.1和公理2.2, 3是自然数。于是根据公理2.3，$3++\neq 0$,即 $4 \neq 0$ 。
</B></font>

---------------

证明了一个很显然的问题，但是数学分析的方法初露端倪，就是很明显的一件事，你可能并不能用逻辑性很强的语言描述，但是数学分析可以

---------------

<font face="黑体" color=#6F6FFF><B>
但是，即使加上了我们的新公理，我们的数系仍然可能会有其他形式的病态性状：
例2.1.7考虑由 $0,1,2,3,4$ 五个数组成的数系，在这个数系中增长运算在数4处碰了“顶确言之，设 $0++=1,1++=2,2++=3$ ,但 $4++=4$ (或另言之，$5=4$ ,从而 $6=4,7=4$ ,等等) 。这与公理2.1、公理2.2和公理2.3都不矛盾。有类似问题的另一个数系是那种增长运算发生回归，但不回归到零的系统，例如假定 $4++=1$ (从而 $5=1,6=1$ 等等)。
</B></font>

---------------

这是另一个漏洞，尽管自然数没有循环了，但是会不会触顶，也就是到了某一个数之后怎么增加都是这个数？
显然我们的自然数不能设计成这样，我们要通过公理来规避这个漏洞

---------------

<font face="黑体" color=#6F6FFF><B>
有很多方法禁止以上性状的发生，但最简单的方法是假定下述公理：
**公理2.4**不同的自然数必有不同的后继者；也就是说，若n，m是自然数且
$n \neq m$，则 $n++\neq m++$ 。等价地说，若 $n++=m++$ ,则必有 n=m
</B></font>

---------------

不同的自然数有不同的后继，如果两个数相等，则其后继相等
那么关于相等的定义我们还没有说，但我们可以先假定我们知道相等是什么含义

---------------

<font face="黑体" color=#6F6FFF><B>
命题2.1.8	6不等于2.
证明反证之，设6=2.那么 $5++= 1++$ 。于是根据公理2.4，我们有 $5 = 1$，从而 $4++= 0++$ 。再根据公理2.4,我们得到 4=0,这与我们前一个命题相矛盾.

</B></font>

---------------

反证法的首次应用，我们必须掌握这个方法，会极大的帮助我们后面的证明过程。
这样我们的数系完整了么？没有，其实这里还有个距离没定义，就是自然数增长计算，每次增长多少，比如从1到2增长了1个单位，但是有没有比1小一点的距离可以增长呢？

---------------

<font face="黑体" color=#6F6FFF><B>
就像从这个命题可以见到的，我们现在好像可以保持全体自然数彼此两两不同。但是，仍然还存在一个问题：就在这些公理（特别是公理2.1和公理2.2)使我们能肯定 $0，1，2，3，\dots$ 。是 $\mathbb{N}$ 的互不相同的元素时，依然存在这样的问题，可能还有另外的不是上述形式的“流氓”元素存在于我们的数系中：
例2.1.9(非正式的）设我们的数系由下述整数的全体和半整数的全体组成： $N := \{0,0.5,1,1.5,2,2.5,3,3.5,\dots \}$ (此例标明是“非正式的”由于我们用到了实数，但我们现在还不能用这些数。）可以验证公理2.1〜2.4对于这个集合依然成立。
我们所需要的是这样一个公理，它使 $\mathbb{N}$ 中只含那种可从0以及增长运算得到的数——以便排除像0.5那样的元素。然而，不使用我们正要定义的自然数就能把 我们说的“可从……得到”量化地弄得更明确是很难的。幸运的是，有一个朴素的解决办法来处理此事：
</B></font>

---------------

出现半个自然数的序列依然满足上面的的所有公理，这样我们还需要另一个公里来补充，那么我们就得出将天天使用的一种方法，归纳法

---------------

<font face="黑体" color=#6F6FFF><B>
**公理2.5** (数学归纳原理）设 $P(n)$ 是关于自然数的一个性质。假设 $P(O)$ 是真的，并假设只要 $P(n)$ 是真的，则 $P(n++)$ 也是真的。那么对于每个自然数 $P(n)$ 都是真的。
注2.1.10 此处关于“性质”指的是什么我们有点不明确，但有这样的一些 $P(n)$ 的例子：“n是偶数”，“n等于3”，“n是方程 $(n+1)^2 =n^2+2n+1$ 的解”，诸如此类。当然，我们尚不曾定义其中的许多概念，但当我们给出了定义，公理2.5就适用于这些性质.[一个逻辑学的注释：由于这个公理不仅说及变量，同时也说及性质，它与其他四个公理具有不同的本质。的确，公理2.5技术上与其叫作公理，不如叫作公理框架(axiom schema)——它是一个产生（无限）多个公理的模板，比说它是单个独立的公理更确切。要进一步讨论这种属性就远超出了本书的范围，然而在逻辑学的范畴中要解决这个问题。
</B></font>

---------------

公理2.5没有给出距离（每次增长多少）的概念，这是后面要讨论的，而是提出了一个框架，像是一个模板，或者是一个有无数个孔的尺子，只有这个孔里的数字算是自然数，这就排除了1.5这种不在孔上的数字，而在不在这个孔了也算是一个性质。
公理2.5是个框架，一旦被证明，就能当做定理使用，而这里需要注意的是公理2.5 的一个基础就是性质的对象是自然数！也就是 $P(n)$ 中的n必然是自然数。然后才能根据框架进行证明

---------------

<font face="黑体" color=#6F6FFF><B>
隐藏在这个公理后面的不正式的直观是这样的。设具有这样的性质: $P(0)$ 为真，并且只要 $P(n)$为真，则 $P(n++)$ 亦真。那么由于 $P(0)$ 真，$P(0++)=P(1)$ 也真。由于 $P(1)$ 真，那么 $P(1++)=P(2)$ 也真。无休止地重复这个步骤，我们看到 $P(0),P(1),P(2),P(3)$ ，等等都是真的——但是这条推理的路线决不会让我们断定譬如 $P(0.5)$ 是真的。于是公理2.5必定对于包含像0.5那样的“不必要”的元素的数系不成立（的确，可以对这个事实给予一个“证明把公理2.5应用于性质为“n不是半整数（即一个整数加0.5)” 。那么 $P(0)$ 是真的，而且若 $P(n)$ 是真的，则 $P(n++)$ 是真的，于是公理2.5断定对于一切自然数 $n$ , $P(n)$ 是真的。也就是说没有一个自然数是半整数。特别地，0.5不能是自然数。这个“证明”并不完全名副其实，因为我们尚未定义像“整数”、“半整数”以及“0.5”这些概念,然而它应该给了你某种关于归纳法原理是如何能防止任何不是“真”的自然数的数出现在 $\mathbb{N}$ 中的思想.）
归纳法原理提供了一个证明一个性质对于每个自然数都真确的方法.于是在本书中往后我们将看到很多具有下述形式的证明：
</B></font>

---------------

这段描述的是归纳法的工作过程，P是对应的自然数的一个性质，可以使你规定的任何一种行之，而归纳法的变量是自然数。

---------------

<font face="黑体" color=#6F6FFF><B>
命题2.1.11 某种性质P(n)对于每个自然数都成立.
证明用归纳法。首先验证基础情形 $n=0$，即证明 $P(0)$（此处插入对于 $P(0)$ 的证明.）现归纳地假定n是一个自然数而 $P(n)$ 也被证实.我们现在来证明  $P(n++)$ 。(此处插入对于 $P(n++)$ 的证明，假定 $P(n)$ 真确。)这就完成了归纳法，从而 $P(n)$ 对于一切数n成立.
当然，我们不必在叙述的词语上或在次序上原封不动地使用上述证明框架，而是一般说来使用与上述形式相像的方式来作归纳证明.我们后面还要述及归纳法的一些花样，如：向后归纳（习题2.2.6)、强归纳（命题2.2.14)以及超限归纳（引理 8.5.15).
</B></font>

---------------

归纳法的证明，或者说证明过程
1. 0对应的形式
2. 假设n时成立
3. 利用n时成立证明n++时成立

当然归纳法还有不少变化，后面会说到

---------------

<font face="黑体" color=#6F6FFF><B>
公理2.1〜2.5就是关于自然数的所谓的Peano公理.这些公理是非常可信的。因此我们作出假设2.6(非正式的）存在一个数系 $\mathbb{N}$ ，称其元素为自然数，公理2.1〜2.5对 于此数系成立.
</B></font>

---------------

提出自然数系

---------------

<font face="黑体" color=#6F6FFF><B>
注2.1.12 我们将把此数系 $\mathbb{N}$ 叫作自然数系.人们当然可能认为存在不只一 个自然数系，例如，我们可以有印度-阿拉伯数系 $\{0,1,2,3，\dots\}$，以及罗马数系 $\{0, I，II，III，IV，\dots\}$，而若我们真的愿意自找麻烦，我们可以把这些数系看成是不 同的东西.但是这些数系明显地是等价的（技术术语是同构（isomorphic))，因为我们可以建立一个一一对应： $0\leftrightarrow 0，1 \leftrightarrow  I，2 \leftrightarrow  II$ ，等等，此对应把印度-阿拉伯系统的零与罗马系统的零对应起来，并且保持增长运算（例如，若2对应于II，则 2++对应于II++).对于这种等价关系的更精确的叙述，参见习题3.5.13.由于自然数系的一切变种都是等价的，说存在不同的自然数系就是毫无意义的事，因此我 们仅使用单独一个自然数系来做数学.
</B></font>

---------------

关于符号问题，等价的数系不同的符号，研究其中一种就可以，还是前面那句话名字叫什么无所谓，重要的是性质

---------------

<font face="黑体" color=#6F6FFF><B>
我们不证假设2.6(即使我们最终将把它包罗到我们的集合论公理之中，见公理 3.7)，这将是我们关于数系所作的唯一的假设•现代分析的一个非凡的成就是，只从这五个非常原始的公理和集合论中的某些附加的公理出发，就能建立起所有的其他的数系，创造函数，并做我们通常所做的全部代数和微积分.
</B></font>

---------------

我们创造了自然数

---------------

<font face="黑体" color=#6F6FFF><B>
注2.1.13(非正式的）自然数系的一个有趣的属性是，每个单个的自然数都是有限的，而自然数的集合是无限的，也就是说，$\mathbb{N}$ 是无限的然而却是由各个有限的元素组成的（整体大于其任何部分)。不存在无限的自然数；只要接受了有限和无限的概念，就可以使用公理2.5来证明此事.（很显然，0是有限的，而若 $n$ 是有限的，则显然 $n++$ 也是有限的.于是根据公理2.5, 一切自然数都是有限的。）这样看来，自然数可以趋于无限,但永远不能实际达到无限;无限不是自然数。（存在其他的数系容纳“无限的”数，例如基数、序数以及p进数，但它们不遵从归纳法，且完全在本书的范围之外)
</B></font>

---------------

自然数的有限与无限，每个数都是有限的，但是自然数的个数是无限的，无限这个概念涉及到集合的基数，另一种自然数的定义方法，但是无限不是自然数是肯定的，你找不到他的前驱，而没有比无限大的这个假设也与公理所矛盾，

---------------

<font face="黑体" color=#6F6FFF><B>
注2.1.14 注意，我们的自然数的定义是公理化的，而不是构造性的。我们不曾告诉你自然数是什么（所以我们不提这样的问题：数是由什么制成的，它们是物理对象吗，它们度量什么，等等）我们仅列出一些你可以用这些数做的一些事情（其实，此刻我们对它们所定义的唯一的运算就是增长)，以及它们所具有的某些性质。数学就是这样干活的——它抽象地处理它的对象，只关注这些对象具有哪 些性质而不管这些对象是什么东西或者有什么意思。如果要做数学，那么一个自然 数是指算盘珠子的一定的排法，还是指一台计算机的存储器中的比特（二进制数中的0或1)的一定的的组织方式，或者指某种没有物质属性的更为抽象的概念，都没有关系；当你能使它们增长时，看看它们中的两个是否相等，然后再做其他的算 术运算，如加法与乘法5它们是为了数学的目的作为数的（只要它们服从必要的公 理).从其他的数学对象出发来构作自然数是可能的（例如从集合出发)，但是构作自然数的实用模型的方式是多种多样的，不过这没关系，至少从数学家的观点来看，争论哪个模型是“真实的”是没什么意义的——只要它们服从所有的公理并正确地运作，对于数学就足够好了.
</B></font>

---------------

数学是怎么干活的，这段很值得我们多次阅读，掌握数学的真谛，理论数学的目标


---------------

<font face="黑体" color=#6F6FFF><B>
注2.1.15 历史上，实现数的公理化处理只是最近的事，比100年早不了太多。在此之前，数总被理解为不可避免地与某种外在的概念相联系,例如联系于计 数一个集合的基数，测量一条线段的长度或一个物体的质量，等等.这种理解自有 其充分的理由，直到人们被迫从一个数系移至另一个数系时为止.例如，用数（sha) 算盘珠子的方式理解数字时，形成数3和数5的概念是很容易的，但对于形成数 -3或|或力或3 + 4i的概念可就不起作用了，于是数的理论每前进一步一负数，非比例数，复数，甚至数零——都引起大量理论的烦恼。19世纪末的一项伟大发现就是，数可以经由公理而抽象地理解，不必要具体的模型。当然，数学家可以使用任何这种模型，只要方便他作直观的理解，但他们也可以容易地抛开这些模型，只要他们开始走上公理化的道路。
</B></font>

---------------

数从形象化到公理化的定义，数学在进步。

---------------

<font face="黑体" color=#6F6FFF><B>
公理化的一个结果是，我们现在可以递归地定义序列。假定我们要建立一个数的序列 $a_0,a_1,a_2\dots$ ，首先定义 $a_0$ 为某个基础的数，例如 $a_0=c$ ，c是某数，然后, 让$a_1$ 是 $a_0$ 的某个函数，$a_1:= f_0(a_0)$ ，$a_2$ 是 $a_1$ 的某个函数，$a_2:= f_1(a_1)$ ，依此类推。一般地，我们令知 $a_{n++} := f_n(a_n)$，其中 $f_n$ 是某个从 $\mathbb{N}$ 到 $\mathbb{N}$ 的函数。使用所有的公理，我们现在可以断定这个过程将对于每个自然数n，给出序列元素 $a_n$ 一个单一的值。确言之:
命题2.1.16(递归定义）设对于每个自然数n，都有某个函数 $f_n:\mathbb{N}\to \mathbb{N}$ 把自然数映成自然数。设c是一个自然数，那么可以对于每个自然数n指定唯一一个自然数 $a_n$ ，使得 $a_0 = c$ 且 $a_{n++}=f_n(a_n)$.
</B></font>

---------------

虽然我们还没学函数，但是这里我们假装我们自己知道这是个啥，其实可以翻译成映射更直白。
这里开始我们开始用自然数构造一些东西，最简单的就是序列，序列是我们后面要经常用到的另一个有力的工具，序列是自然数最原始的扩展，多个或者无限个自然数组成的组合，而这里用到一个更深远的一个工具是递归定义，类似于但不等同于公理2.5 中的 n和n++ 的递增证明方式，证明一个自然数序列：

---------------

<font face="黑体" color=#6F6FFF><B>
证明(非正式的）用归纳法
首先看到，这个过程给 $a_0$ 一个单一的值，即 $c$ (根据公理2.3没有其他的定义知再次定义的值.）现归纳地假设此过程给 $a_n$ 以一个单一的值，那么它赋予 $a_{n++}$ 一个单一的值 $a_{n++}=f_n(a_n)$  (根据公理2.4，没有其他的定义 $a_{m++}:=f_m(a_m)$ 能再次定义 $a_{n++}$ )这就完成了归纳法，从而对于每个自然数 $n$ ，如被赋予了一个单一的值。
</B></font>

---------------

我们要证明的是 $a_n$  具有单一值，用归纳法证明递归定义的正确性。注意单一值是 $a_n$ 只能有一个值，不可能同时等于1和2，而不是说 $a_n\neq a_i \text{ for } n\neq i$  序列中可以出现相等的情况。

---------------

<font face="黑体" color=#6F6FFF><B>
注意，这里所有的公理是怎样必须被用到了。在一个具有某种回归（wraparound) 的系统中，递归定义无法工作，因为序列的某些元素常常会被再次定义。例如，在例2.1.5中，其中 3++ = 0,那么对于 $a_0$ 就会（至少）有两个冲突的定义，或者c，或者 $f_3(a3)$ .在一个具有多余元素如0.5的系统中，元素 $a_{0.5}$ 永不会被定义.
递归定义的方法是非常有效的.例如，可以用这种方法来定义加法和乘法，我们现在就来做这件事.
</B></font>

---------------

这个证明过程值得我们多次阅读，注意递归不能用到循环的系统中，不然就会无穷无尽，无始无终！
使用递归定义的完整逻辑过程，以及注意实现，比如有些标号永不会被证明——0.5 ，有些很矛盾等等，这些都是满足前面五个公理的。
归纳法像是一个无限长的尺子，直接给出了所有

## 总结
Peano公理，归纳法，递归定义，这些是本文的重点，而其中关于数学任务的描述和说明更是精彩！
